// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------

enum Role {
  USER
  EMPLOYEE
  ADMIN
}

model User {
  id             Int      @id @default(autoincrement())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  name           String?
  email          String   @unique
  hashedPassword String?
  role           String   @default("EMPLOYEE")

  tokens   Token[]
  sessions Session[]
}

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?

  user   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Token {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  hashedToken String
  type        String
  // See note below about TokenType enum
  // type        TokenType
  expiresAt   DateTime
  sentTo      String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([hashedToken, type])
}

// NOTE: It's highly recommended to use an enum for the token type
//       but enums only work in Postgres.
//       See: https://blitzjs.com/docs/database-overview#switch-to-postgre-sql
// enum TokenType {
//   RESET_PASSWORD
// }

// Application models

model Ingredient {
  id              Int         @id @default(autoincrement())
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  name            String
  unitMeasurement String?
  quantity        Float?
  Beverage        Beverage?   @relation(fields: [beverageId], references: [id])
  beverageId      Int?
  Sandwiches      Sandwiches? @relation(fields: [sandwichesId], references: [id])
  sandwichesId    Int?
  Additional      Additional? @relation(fields: [additionalId], references: [id])
  additionalId    Int?
}

model Beverage {
  id              Int          @id @default(autoincrement())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  name            String
  unitMeasurement String?
  quantity        Float?
  industrialized  Boolean      @default(false)
  ingredients     Ingredient[]
  // Product         Product[]
}

model Sandwiches {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  name        String
  description String?
  ingredients Ingredient[]
  // Product     Product[]
}

model Additional {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  name        String
  price       Int
  priceScale  Int          @default(2)
  ingredients Ingredient[]
  //Product     Product?     @relation(fields: [productId], references: [id])
  //productId   Int?
}

model Product {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isActive    Boolean  @default(true)
  name        String
  description String?
  price       Int
  priceScale  Int      @default(2)

  //beveragesOptions Beverage[]
  //additionalOptions Additional[] // Acho que esse campo pode ser apagado, e os adicionais ficarem ligados ao pedido

  //Sandwiches   Sandwiches? @relation(fields: [sandwichesId], references: [id])
  //sandwichesId Int?
  //Sale         Sale?       @relation(fields: [saleId], references: [id])
  //saleId       Int?

  // Beverage     Beverage?   @relation(fields: [beverageId], references: [id])
  // beverageId   Int?
  // Sale   Sale? @relation(fields: [saleId], references: [id])
  // saleId Int?
}

model CashRegister {
  id        Int        @id @default(autoincrement())
  createdAt DateTime   @default(now())
  closedAt  DateTime   @updatedAt
  isClosed  Boolean    @default(false)
  Order     Order[]
  OrderPad  OrderPad[]
}

enum ORDER_TYPES {
  WITHDRAWAL
  LOCAL
  DELIVERY
}

// delivery types: deliveryType : place, delivery, takeout

enum ORDER_STATUS {
  OPEN
  PREPARING
  READY
  DELIVERED
  CANCELED
}

model Order {
  id                Int           @id @default(autoincrement())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  deliveryTime      DateTime?
  deliveryType      String
  amount            Int           @default(0)
  amountScale       Int           @default(2)
  status            ORDER_STATUS  @default(PREPARING)
  tableReference    String?
  deliveryReference String?
  OrderPad          OrderPad?     @relation(fields: [orderPadId], references: [id])
  orderPadId        Int?
  products          Json?
  CashRegister      CashRegister? @relation(fields: [cashRegisterId], references: [id])
  cashRegisterId    Int?
}

enum ORDER_PAD_STATUS {
  OPEN
  CLOSED
  CANCELED
}

model OrderPad {
  id             Int              @id @default(autoincrement())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  amount         Int              @default(0)
  amountScale    Int              @default(2)
  status         ORDER_PAD_STATUS @default(OPEN)
  holderName     String
  tableReference String?
  orders         Order[]
  CashRegister   CashRegister?    @relation(fields: [cashRegisterId], references: [id])
  cashRegisterId Int?
}

enum SALE_STATUS {
  OPEN
  CLOSED
  CANCELED
}

enum INVOICE_STATUS {
  NOT_GENERATED
  TRANSMITED
  PENDING
  CONTIGENCY
  PROCESSING
  AUTHORIZED
  DENIED
  REJECTED
}

model Sale {
  id                     Int            @id @default(autoincrement())
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  amount                 Int            @default(0)
  amountScale            Int            @default(2)
  status                 SALE_STATUS    @default(OPEN)
  // products               Product[]
  invoice_number         String         @default("")
  invoice_status         INVOICE_STATUS @default(NOT_GENERATED)
  customerDocument       String?
  paymentMethod          String?
  deliveryFeeAmount      Int            @default(0)
  deliveryFeeAmountScale Int            @default(2)
}
